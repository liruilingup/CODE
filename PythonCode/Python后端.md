# 一、计算机网路

## UDP和TCP
### UDP协议全称是用户数据报协议(面向报文的)  
当报文发送之后，是无法得知其是否安全完整到达的。
1、无连接
2、有单播，多播，广播的功能
3、UDP是面向报文的
4、不可靠性

UDP 头部包含了以下几个数据：  
    两个十六位的端口号，分别为源端口（可选字段）和目标端口  
    整个数据报文的长度  
    整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误  

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

### TCP协议
1、面向连接
2、仅支持单播传输
3、面向字节流，TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
4、可靠传输
判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。提供拥塞控制
5、拥塞控制
当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞
6、TCP提供全双工通信(CP连接的两端都设有缓存，用来临时存放双向通信的数据)
为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误
接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传
### TCP可靠传输的实现
所谓的可靠，就是能保证数据的正确性，无差错、不丢失、不重复、并且按序达到。
TCP首先采用三次握手来建立连接、四次挥手来释放连接，自动重传请求保证数据传输的正确性
### 流量控制
控制发送端发送速率，以便接收端来得及接受
接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。
发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。

当发送方收到接受窗口 win = 0 时，这时发送方停止发送报文，并且同时开启一个定时器，每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。

### TCP之滑动窗口
[解析TCP之滑动窗口(动画演示)](https://blog.csdn.net/yao5hed/article/details/81046945)

### 拥塞控制
四种拥塞控制算法
1.慢开始： cwnd呈现指数增长趋势
2.拥塞控制：cwmd>ssthresh  呈现线性增长趋势
3.快重传：发送方只要一连接收到三个重复确认就应该立即重传对方尚未的报文段，而不必等到重传计时器超时后发送。由3个重复应答判断有包丢失，重新发送丢包的信息。
4.快恢复  
[TCP的拥塞控制（详解）](https://blog.csdn.net/qq_41431406/article/details/97926927)
[详解TCP中的拥塞控制](https://blog.csdn.net/m0_37962600/article/details/79993310)
### 判断网络是否进入拥塞状态
通过观察网络的吞吐量与网络负载间的关系：  
    如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就进入例如轻度拥塞的状况。  
    如果网络得吞吐量随着网络负载的增大反而下降，那么网络就可能进入拥塞状态。  
    如果网络的负载继续增大，而网络的吞吐量下降到零，网络就可能进入了死锁状态。  

### TCP三次握手第三次握手时ACK丢失
如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。
如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。
但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包(用于强制关闭tcp连接)响应，方能感知到Server的错误。

### HTTPS的连接过程

[HTTPS 建立连接的详细过程](https://www.cnblogs.com/liyuhui-Z/p/7844880.html)

### ARP协议
[ARP地址解析协议原理](https://www.cnblogs.com/csguo/p/7542944.html)


### TIME-WAIT的原因

### SYN Flooding
如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。
1．无效连接监视释放
[什么是SYN Flood攻击](https://www.cnblogs.com/popduke/p/5823801.html#1ref)

### DNS协议
ARP协议是用来将IP地址转换为MAC地址，那么DNS协议则是用来将域名转换为IP地址  
域名和IP的对应关系保存在一个叫hosts文件中
[DNS域名解析协议详解](https://blog.csdn.net/baidu_37964071/article/details/80500825)


# 二、操作系统

### 进程和线程

[进程和线程](https://blog.csdn.net/rui_rui96/article/details/109277314)

### 进程间的通信方法
1、管道(数据单向流动，父进程->子进程)
2、FIFO
3、消息队列，消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识
4、信号量：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
5、共享内存，两个或多个进程共享一个给定的存储区，因为多个进程可以同时操作，所以需要进行同步

1.管道：速度慢，容量有限，只有父子进程能通讯    
2.FIFO：任何进程间都能通讯，但速度慢    
3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
4.信号量：不能传递复杂消息，只能用来同步    
5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

### 信号量的实际应用
实现进程互斥

### 进程的同步和互斥
在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。
* 临界资源  
虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源
* 同步  
进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。

* 互斥


### 线程的同步和互斥
同步就是协同步调，按预定的先后次序进行运行  
线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源  

互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。
互斥是一种特殊的同步。

### 操作系统进程调度算法
最短工作优先（SJF）    
最短剩余时间优先（SRTF）   
最高响应比优先（HRRF）  
优先级调度（Priority）  
轮转调度（RR）  

# 三、数据库
### Mysql为什么用B+树不是B树
B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。    


IO次数更少：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
遍历更加方便：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好
但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图:
[参考](https://www.cnblogs.com/kungfupanda/p/12776674.html)

### 多对多关系如何实现
[表间的关系一对多/一对一/多对多关系是怎样建立的？](https://www.cnblogs.com/panxuejun/p/5977064.html)


### 数据库acid实现原理
[ACID的实现原理](https://www.cnblogs.com/zhouxiaohong/p/13679462.html)

### 幻读

### 联合索引
两个或更多个列上的索引被称作联合索引
创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。

### 什么情况下建索引
哪些字段可以建索引，一般都where、order by 或者 group by 后面的字段。


### 什么情况下应不建或少建索引
1、表记录太少  
如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，这种情况下ORACLE至少要往返读取数据块两次。而不用索引的情况下ORACLE会将所有的数据一次读出，处理速度显然会比用索引快。
2、经常插入、删除、修改的表  
对一些经常处理的业务表应在查询允许的情况下尽量减少索引  
3、数据重复且分布平均的表字段  
假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度  
4、经常和主字段一块查询但主字段索引值比较多的表字段    
表经常按收费序号、户标识编号、抄表日期、电费发生年月、操作 标志来具体查询某一笔收款的情况，如果将所有的字段都建在一个索引里那将会增加数据的修改、插入、删除时间，从实际上分析一笔收款如果按收费序号索引就已 经将记录减少到只有几条，如果再按后面的几个字段索引查询将对性能不产生太大的影响。

### MySQL的二级索引
二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。
[mysql——二级索引（辅助索引）](https://www.cnblogs.com/gaoquanquan/p/11030999.html)

### 非关系型数据库
1、redis， web
2、MongoDB,文档数据库——这些数据库通常将每个键与称为文档的复杂数据结构配对
3、Hbase,谷歌为BigTable数据库设计的分布式非关系数据库。宽列存储——这些类型的数据库针对大型数据集上的查询进行了优化，它们将数据列存储在一起
[几种常用非关系型数据库](https://www.cnblogs.com/jerryliuxin/p/12194613.html)

# 四、Python
### dict的底层实现
[哈希表的实现原理](https://blog.csdn.net/rui_rui96/article/details/109230064)

### list各种操作的复杂度

### range和xrange的区别
range()返回一个递增或递减的数字列表，列表的元素由三个参数决定  
xrange则不会直接生成一个list，而是每次调用返回其中的一个值，内存空间使用极少，因而性能非常好  

要是视频通话改为TCP传输，会发生什么？  
视频是UDP，因为要实时性，  
UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

要是缓冲区就100个字节，发送方发送了200个字节，另外100个字节怎么半？丢弃吗







